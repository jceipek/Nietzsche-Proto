if (Meteor.isClient) {

  // Session Variables:
  //
  // task // keeps track of what the user is doing (searching, comparison, or looking at directions)
  
  // Global Objects:
  // comparison :
  //  {
  //    ctx
  //    initialTime
  //  }
  
  var Comparison = {
    ctx: null,
    initialTime: null,
    scalingFactor: 0.2,
    width: document.width,
    height: document.height
  };

  // Lets the templating system determine which templates to display
  Template.main.task = function (task) {
    return Session.get("task") === task;
  };

  Template.main.events({
    /* Meteor autogenerated
    'click input' : function () {
      // template data, if any, is available in 'this'
      if (typeof console !== 'undefined')
        console.log("You pressed the button");
    }
    */
  });

  var posFromTime = function (time) {
    // Convert to seconds and scale by scalingFactor
    return (time - Comparison.initialTime)/1000 * Comparison.scalingFactor;
  }; 

// START DRAWING FUNCTIONS //
  var drawRouteLine = function (ctx, xStart, xEnd, yMid, thickness, startRounded, endRounded) {
    /* For a given canvas context ctx,
     * draw a rounded route line from xStart to xEnd, centered on yMid with a given thickness.
     * Round the beginning of the line if startRounded is true.
     * Round the end of the line if endRounded is true.
    */
    ctx.beginPath();
    var radius = thickness/2;
    if (startRounded) {
      ctx.arc(xStart+radius, yMid, radius, Math.PI/2, -Math.PI/2, false);
    } else {
      ctx.moveTo(xStart, yMid+radius);
      ctx.lineTo(xStart, yMid-radius);
    }
    if (endRounded) {
      ctx.arc(xEnd-radius, yMid, radius, -Math.PI/2, Math.PI/2, false);
    } else {
      ctx.lineTo(xEnd, yMid-radius);
    }
    ctx.lineTo(xEnd, yMid+radius);
    ctx.fill();
  };

  var plotSingleRoute = function (route, yMid) {
    var ctx = Comparison.ctx;
    var timeOffset = route.legs[0].departure_time.value;
    var steps = route.legs[0].steps;
    for (var stepIdx = 0; stepIdx < steps.length; stepIdx++) {
        if (steps[stepIdx].travel_mode === "TRANSIT") {
          ctx.fillStyle = steps[stepIdx].transit.line.color; // XXX: This is sometimes undefined (black)
          timeOffset = new Date(steps[stepIdx].transit.departure_time.value);
        } else {
          ctx.fillStyle = "rgb(0,0,0)"; 
        }
        var firstRounded = (stepIdx === 0);
        var lastRounded = (stepIdx === steps.length-1);

        var stepStart = posFromTime(timeOffset);
        
        var stepEnd = new Date(timeOffset);
        stepEnd.setSeconds(stepEnd.getSeconds()+steps[stepIdx].duration.value);
        stepEnd = posFromTime(stepEnd);
        
        drawRouteLine(ctx, stepStart, stepEnd, yMid, 10, firstRounded, lastRounded);
        timeOffset.setSeconds(timeOffset.getSeconds()+steps[stepIdx].duration.value);
    }
    console.log(timeOffset);
  };

  var plotTimeIntervals = function () {
    console.log("PLOT");
    var currIntervalTime = new Date(Comparison.initialTime);
    currIntervalTime.setMinutes(0);
    var ctx = Comparison.ctx;
    while (posFromTime(currIntervalTime) < document.width) {
      currIntervalPos = posFromTime(currIntervalTime); 
      var startY = 0;
      ctx.beginPath();
      if ((currIntervalTime.getMinutes() % 10) === 0) {
        console.log("Black "+currIntervalPos);
        ctx.strokeStyle = "rgb(0, 0, 0)";
      } else if ((currIntervalTime.getMinutes() % 5) === 0) {
        console.log("Grey "+currIntervalPos);
        ctx.strokeStyle = "rgb(200, 200, 200)";
        startY = 15;
      }
      ctx.moveTo(currIntervalPos, startY);
      ctx.lineTo(currIntervalPos, document.height);
      ctx.stroke();
      currIntervalTime.setMinutes(currIntervalTime.getMinutes()+5);
    }
  }
// END DRAWING FUNCTIONS //

  var initializeComparisonCanvas = function () {
    var canvas = $('#graphical-comparison')[0];
    canvas.width = document.width;
    canvas.height = document.height;
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');
      Comparison.ctx = ctx;
      Comparison.initialTime = new Date(1350757867064); // XXX: TODO: Change back to Date()
    } else {
      // TODO: Fallback mechanism
      console.log("canvas isn't supported");
    }
 
  };

  var findRoutes = function () {
    var router = new google.maps.DirectionsService();
    // TODO: Currently hardcoded! Make it not so.
    var request = {
      origin: "Harvard Square, Boston, MA",
      destination: "Boston Public Library",
      travelMode: google.maps.TravelMode.TRANSIT,
      transitOptions: {
        departureTime: Comparison.initialTime
      },
      provideRouteAlternatives: true,
      unitSystem: google.maps.UnitSystem.IMPERIAL
    };
    router.route(request, function (response, status) {
      if (status == google.maps.DirectionsStatus.OK) {
        console.log(response);
        var horizontalRouteOffset = 70;
        plotTimeIntervals();        
        for (var routeIdx = 0; routeIdx < response.routes.length; routeIdx++) {
          plotSingleRoute(response.routes[routeIdx], (routeIdx + 1) * horizontalRouteOffset);
        }
      }  
    });
  }

  // Fired whenever the DOM is ready for the routeComparison template
  Template.routeComparison.rendered = function() {
      if(!this._rendered) {
        initializeComparisonCanvas();
        findRoutes();
        this._rendered = true;
        console.log('Template onLoad');
      }
  };

  // When the application starts
  Meteor.startup(function () {
    // "task" will keep track of what the user is doing
    //Session.set("task", "route-searching"); // Choosing From and To initially
    Session.set("task", "route-comparison"); // Choosing between routes graphically
    //Session.set("task", "route-directions"); // How to use the route
  });
}
